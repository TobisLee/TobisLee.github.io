<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tobislee.github.io/</id>
    <title>Leon&apos;s Blog</title>
    <updated>2019-12-16T08:37:09.993Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tobislee.github.io/"/>
    <link rel="self" href="https://tobislee.github.io//atom.xml"/>
    <subtitle>脚踏实地，仰望星空</subtitle>
    <logo>https://tobislee.github.io//images/avatar.png</logo>
    <icon>https://tobislee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Leon&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode 300. Longest Increasing Subsequence]]></title>
        <id>https://tobislee.github.io//post/leetcode-300-longest-increasing-subsequence</id>
        <link href="https://tobislee.github.io//post/leetcode-300-longest-increasing-subsequence">
        </link>
        <updated>2019-12-16T08:21:32.000Z</updated>
        <summary type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<!-- more -->
<p><strong>Example:</strong></p>
<pre><code>Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> complexity.</li>
</ul>
<p><strong>Follow up:</strong> Could you improve it to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> time complexity?</p>
<h2 id="idea">Idea</h2>
<p>准备一个vector，用来保存最长递增子序列，遍历原数组，当原数组中的某个值比vector中的所有值都大，那么就放到最后，否则，选择vector中第一个比它大的值，将它替换。</p>
<p>时间复杂度:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>
空间复杂度:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="solution">Solution</h2>
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; lis;
        for (int i = 0; i &lt; nums.size(); i++) {
            auto iter = lower_bound(lis.begin(), lis.end(), nums[i]);
            if(iter == lis.end()) lis.push_back(nums[i]);
            else *iter = nums[i];
        }
        for (int i=0; i &lt; lis.size();i++) {
            cout &lt;&lt; lis[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        return lis.size();
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 287. Find the Duplicate Number]]></title>
        <id>https://tobislee.github.io//post/leetcode-287-find-the-duplicate-number</id>
        <link href="https://tobislee.github.io//post/leetcode-287-find-the-duplicate-number">
        </link>
        <updated>2019-12-14T12:38:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<!-- more -->
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,3,4,2,2]
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [3,1,3,4,2]
Output: 3
</code></pre>
<p><strong>Note:</strong></p>
<ol>
<li>You <strong>must not</strong> modify the array (assume the array is read only).</li>
<li>You must use only constant,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> extra space.</li>
<li>Your runtime complexity should be less than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ol>
<h2 id="idea">Idea</h2>
<p>将数组的元素看成数组下标，可以发现，这是一个类似于找链表中的环的问题，使用快慢指针可以解决这种问题。<br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        if (nums.size() &gt; 1)
        {
            int slow = nums[0];
            int fast = nums[nums[0]];
            while (slow != fast)
            {
                slow = nums[slow];
                fast = nums[nums[fast]];
            }

            fast = 0;
            while (fast != slow)
            {
                fast = nums[fast];
                slow = nums[slow];
            }
            return slow;
        }
        return -1;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 中批量杀死进程]]></title>
        <id>https://tobislee.github.io//post/linux-zhong-pi-liang-sha-si-jin-cheng</id>
        <link href="https://tobislee.github.io//post/linux-zhong-pi-liang-sha-si-jin-cheng">
        </link>
        <updated>2019-12-13T06:05:42.000Z</updated>
        <summary type="html"><![CDATA[<p>用ssh连接到服务器去跑程序时，本地主机突然卡死，重启后重新ssh到服务器，发现服务器中的程序还在跑，但已经看不到结果了，所以想杀掉进程后重新跑。</p>
]]></summary>
        <content type="html"><![CDATA[<p>用ssh连接到服务器去跑程序时，本地主机突然卡死，重启后重新ssh到服务器，发现服务器中的程序还在跑，但已经看不到结果了，所以想杀掉进程后重新跑。</p>
<!-- more -->
<p>于是我先通过</p>
<blockquote>
<p>nvidia-smi</p>
</blockquote>
<p>找到正在跑的进程PID，然后执行</p>
<blockquote>
<p>kill -9 PID</p>
</blockquote>
<p>杀死进程，这时显卡进程中显示程序被杀掉，但是显卡的显存还是非常高，所以程序应该还是在跑，于是执行</p>
<blockquote>
<p>htop</p>
</blockquote>
<p>查看进程，发现确实在跑，并且不止一个PID，于是执行</p>
<blockquote>
<p>kill -9 <code>ps -aux | grep XXXX | awk '{print $2}'</code></p>
</blockquote>
<p>解释一下上面的指令：</p>
<ol>
<li><code>ps -aux：</code> 列出进程</li>
<li><code>grep XXXX:</code> 通过grep + 管道，可以筛选出想要杀掉的进程（这里的XXXX代表着你想要杀掉的进程的标志）</li>
<li><code>awk '{print $2}':</code> 获得筛选出来的进程信息的第二列信息，也就是进程号</li>
<li><code>kill -9 PID:</code> 根据进程号杀掉进程</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 279. Perfect Squares]]></title>
        <id>https://tobislee.github.io//post/leetcode-279-perfect-squares</id>
        <link href="https://tobislee.github.io//post/leetcode-279-perfect-squares">
        </link>
        <updated>2019-12-13T03:05:05.000Z</updated>
        <summary type="html"><![CDATA[<p>Given a positive integer n, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to n.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Given a positive integer n, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to n.</p>
<!-- more -->
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
</code></pre>
<h2 id="idea">Idea</h2>
<ol>
<li>使用dp，dp数组表示构成当前这个数的最少平方数的个数，状态转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>∗</mo><mi>j</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i] = min(dp[i], dp[i-j*j]+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>使用数学方法<br>
用数学理论可以证明这个问题只有四种答案，即<code>1,2,3,4</code>。<br>
由<code>1</code>个平方数构成的就是平方数<br>
由<code>2</code>个平方数构成的数的特点：减掉一个平方数，之后还是一个平方数<br>
由<code>4</code>个平方数构成的数应该满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>k</mi></msup><mo>(</mo><mn>8</mn><mo>∗</mo><mi>m</mi><mo>+</mo><mn>7</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">4^k(8*m+7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>。<br>
剩下的就是由<code>3</code>个平方数构成的数</li>
</ol>
<h2 id="solution-1-dp">Solution 1 --- dp</h2>
<pre><code class="language-cpp">class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n+1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j*j &lt;= i; j++) {
                dp[i] = min(dp[i], dp[i - j*j]+1);
            }
        }
        return dp.back();
    }
};
</code></pre>
<h2 id="solution-2-math">Solution 2 --- math</h2>
<pre><code class="language-cpp">class Solution {
private:
    bool isSquare(int n) {
        int sqrt_n = (int)sqrt(n);
        return (sqrt_n*sqrt_n == n);
    }
public:
    int numSquares(int n) {
        if (isSquare(n)) {return 1;}
        while ((n &amp; 3) == 0) {
            // n%4 == 0
            n &gt;&gt;= 2;
        }
        if ((n &amp; 7) == 7) {return 4;}
        int sqrt_n = (int)sqrt(n);
        for (int i =1; i &lt;= sqrt_n; i++) {
            if (isSquare(n-i*i)) {return 2;}
        }
        return 3;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 240. Search a 2D Matrix II]]></title>
        <id>https://tobislee.github.io//post/leetcode-240-search-a-2d-matrix-ii</id>
        <link href="https://tobislee.github.io//post/leetcode-240-search-a-2d-matrix-ii">
        </link>
        <updated>2019-12-12T03:52:09.000Z</updated>
        <summary type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<!-- more -->
<p><strong>Example:</strong></p>
<p>Consider the following matrix:</p>
<pre><code>[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</code></pre>
<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
<h2 id="idea">Idea</h2>
<p>由于该题中的矩阵是比较特殊的矩阵，为了减少搜索空间，此题应该从右上角的元素开始检索。</p>
<ol>
<li>如果<code>target</code>=右上角的元素，<code>return true</code></li>
<li>如果<code>target&lt;</code>右上角的元素，说明这一列的元素都比<code>target</code>要大，所以应该到左边一列去找</li>
<li>如果<code>target&gt;</code>右上角的元素，说明这一行的元素都比<code>target</code>要小，所以应该到下边一行去找</li>
</ol>
<p>时间复杂度：<code>O(m+n)</code><br>
空间复杂度：<code>O(1)</code></p>
<h2 id="solution">Solution</h2>
<pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int m = matrix.size();
        int n = m ? matrix[0].size() : 0;
        int r = 0;
        int c = n-1;
        while (r&lt;m &amp;&amp; c&gt;=0) {
            if (matrix[r][c] == target) {
                return true;
            }
            if (matrix[r][c] &gt; target) c--;
            else r++;
        }
        return false;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 238. Product of Array Except Self]]></title>
        <id>https://tobislee.github.io//post/leetcode-238-product-of-array-except-self</id>
        <link href="https://tobislee.github.io//post/leetcode-238-product-of-array-except-self">
        </link>
        <updated>2019-12-11T08:16:26.000Z</updated>
        <summary type="html"><![CDATA[<p>Given an array <code>nums</code> of n integers where n &gt; 1,  return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Given an array <code>nums</code> of n integers where n &gt; 1,  return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>
<!-- more -->
<p><strong>Example:</strong></p>
<pre><code>Input:  [1,2,3,4]
Output: [24,12,8,6]
</code></pre>
<p><strong>Note:</strong> Please solve it <strong>without division</strong> and in O(n).</p>
<p><strong>Follow up:</strong><br>
Could you solve it with constant space complexity? (The output array <strong>does not</strong> count as extra space for the purpose of space complexity analysis.)</p>
<h2 id="idea">Idea</h2>
<ol>
<li>使用两个数组，一个保存从开始到当前位置的前一个元素的累乘，一个保存从末尾到当前位置后一个元素的累乘，最后的结果只是将两个数组的元素相乘。<br>
时间复杂度：<code>O(n)</code><br>
空间复杂度：<code>O(n)</code></li>
<li>将两个数组替换成两个整数。<br>
时间复杂度：<code>O(n)</code><br>
空间复杂度：<code>O(1)</code></li>
</ol>
<h2 id="solution-2">Solution 2</h2>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int fromBegin = 1;
        int fromEnd = 1;
        vector&lt;int&gt; res(n, 1);
        for (int i = 0; i &lt; n; i++) {
            res[i] *= fromBegin;
            fromBegin *= nums[i];
            res[n-1-i] *= fromEnd;
            fromEnd *= nums[n-i-1];
        }
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 236. Lowest Common Ancestor of a Binary Tree]]></title>
        <id>https://tobislee.github.io//post/leetcode-236-lowest-common-ancestor-of-a-binary-tree</id>
        <link href="https://tobislee.github.io//post/leetcode-236-lowest-common-ancestor-of-a-binary-tree">
        </link>
        <updated>2019-12-10T14:40:38.000Z</updated>
        <summary type="html"><![CDATA[<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
]]></summary>
        <content type="html"><![CDATA[<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<!-- more -->
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</code></pre>
<p><strong>Note:</strong></p>
<pre><code>- All of the nodes' values will be unique.
- p and q are different and both values will exist in the binary tree.
</code></pre>
<h2 id="idea">Idea</h2>
<p>该题使用递归去做。<br>
该题一共有三种情况：</p>
<ol>
<li><code>p</code>,<code>q</code>在根节点左右子树上。</li>
<li><code>p</code>和<code>q</code>在同一子树上，但<code>p</code>在<code>q</code>的上面</li>
<li><code>p</code>和<code>q</code>在同一子树上，但<code>q</code>在<code>p</code>的上面</li>
</ol>
<h2 id="solution">Solution</h2>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        return !left ? right : !right ? left : root;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 221. Maximal Square]]></title>
        <id>https://tobislee.github.io//post/leetcode-221-maximal-square</id>
        <link href="https://tobislee.github.io//post/leetcode-221-maximal-square">
        </link>
        <updated>2019-12-09T06:45:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p>
<!-- more -->
<p><strong>Example:</strong></p>
<pre><code>Input: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
</code></pre>
<h2 id="idea-1">Idea 1</h2>
<p>使用DP，我们定义<code>dp[i][j]</code>为从点<code>[i][j]</code>开始，向左上角延伸，能构成的正方形的最大边长。<br>
对于最上边的行<code>i=0</code>和最左边的列<code>j=0</code>来说，<code>dp[i][j] = matrix[i][j] - '0'</code>，因为当元素为1时，就构成了一个边长为1的正方形；当元素为0时，则不构成正方形，所以边长为0。<br>
当<code>i,j &gt; 0</code>时:<br>
如果<code>matrix[i][j] = 0:</code>说明这个格子不能构成正方形，所以<code>dp[i][j] = 0</code>；<br>
如果<code>matrix[i][j] = 1:</code>说明这个格子可以构成正方形，我们要看他的左边、上边、左上角的元素的值，（这也是DP的精髓），他们保存着目前能够构成的正方形的最大边长，我们取他们之中最小的，然后+1，继续遍历，直到遍历完整个数组。<br>
最后，我们取出dp数组中最大的元素，返回该值的平方。<br>
时间复杂度：<code>O(mn)</code><br>
空间复杂度：<code>O(mn)</code></p>
<h2 id="solution-1">Solution 1</h2>
<pre><code class="language-cpp">class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.empty()) return 0;
        int m = matrix.size();
        int n = matrix[0].size();
        int side_length = 0;
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (!i || !j || matrix[i][j] == '0')
                    dp[i][j] = matrix[i][j] - '0';
                else {
                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;
                }
                side_length = max(dp[i][j], side_length);
            }
        }
        return side_length * side_length;
    }
};
</code></pre>
<h2 id="idea-2">Idea 2</h2>
<p>上面的解决方案需要维护一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的矩阵，但我们实际用到的其实就是两行矩阵，所以我们可以只维护这两行矩阵。<br>
时间复杂度：<code>O(mn)</code><br>
空间复杂度：<code>O(n)</code></p>
<h2 id="solution-2">Solution 2</h2>
<pre><code class="language-cpp">// boost
static const int __ = []() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    return 0;
}();
class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.size() == 0) return 0;
        int m = matrix.size();
        int n = matrix[0].size();
        int side_length = 0;
        vector&lt;int&gt; pre(n, 0);
        vector&lt;int&gt; cur(n, 0);
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (matrix[i][j] == '0' || !i || !j) {
                    cur[j] = matrix[i][j] - '0';
                }
                else {
                    cur[j] = min(pre[j-1], min(pre[j], cur[j-1])) + 1;
                }
                side_length = max(cur[j], side_length);
            }
            // fill(pre.begin(), pre.end(), 0);
            // swap(pre, cur);
            swap(pre, cur);
            fill(cur.begin(), cur.end(), 0);
        }
        return side_length*side_length;
    }
};
</code></pre>
<h2 id="idea-3">Idea 3</h2>
<p>其实，我们只是希望获得<code>dp[i-1][j-1], dp[i-1][j], dp[i][j-1]</code>的值，所以我们可以考虑用一个数组，加上一个变量来做。<br>
其中，<code>top_left</code>代表<code>dp[i][j]</code>左上角的元素，即<code>dp[i-1][j-1]</code>；<br>
<code>vector&lt;int&gt; cur(n)</code>要分成两部分来看，从<code>[0, j-1]</code>代表本行新更新的dp值，<code>[j, n-1]</code>代表上一行的dp值，等待着更新。<br>
时间复杂度：<code>O(mn)</code><br>
空间复杂度：<code>O(n)</code></p>
<pre><code class="language-cpp">static const int __ = []() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    return 0;
}();
class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.size() == 0) return 0;
        int m = matrix.size();
        int n = matrix[0].size();
        int side_length = 0;
        int pre = 0;
        vector&lt;int&gt; cur(n, 0);
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                int temp = cur[j];
                if (matrix[i][j] == '0' || !i || !j) {
                    cur[j] = matrix[i][j] - '0';
                }
                else {
                    cur[j] = min(pre, min(cur[j-1], cur[j])) + 1;
                }
                side_length = max(cur[j], side_length);
                pre = temp;
            }
        }
        return side_length*side_length;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 215. Kth Largest Element in an Array]]></title>
        <id>https://tobislee.github.io//post/leetcode-215-kth-largest-element-in-an-array</id>
        <link href="https://tobislee.github.io//post/leetcode-215-kth-largest-element-in-an-array">
        </link>
        <updated>2019-12-08T12:00:57.000Z</updated>
        <summary type="html"><![CDATA[<p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest  element in the sorted order, not the kth distinct element.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest  element in the sorted order, not the kth distinct element.</p>
<!-- more -->
<p><strong>Example 1:</strong></p>
<pre><code>Input: [3,2,1,5,6,4] and k = 2
Output: 5
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
</code></pre>
<p><strong>Note:</strong><br>
You may assume k is always valid, 1 ≤ k ≤ array's length.</p>
<h2 id="idea">Idea</h2>
<ol>
<li>
<p>将数组从小到大排序，然后返回第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">N-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大的元素。</p>
<p>TO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p>SO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>将数组从大到小排序，然后返回第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>大的元素。</p>
<p>TO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p>SO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>使用c++内置函数<code>nth_element</code> ，函数用法：<code>nth_element(a.begin()+l, a.begin()+k, a.begin()+r)</code> ，该函数会使<code>a</code>这个数组中<code>[l, r)</code>内的第<code>k</code>小的元素处在第<code>k</code>个位置上（相对位置），即：比他小的都在它的左侧，比它大的都在它的右侧，但是这个函数不保证其他元素有序<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<p>TO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是区间长度。</p>
<p>SO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>使用c++内置函数<code>partial_sort</code>，函数用法：</p>
<p><code>partial_sort(a.begin()+l, a.begin()+k, a.begin()+r)</code> ，该函数会使<code>a</code>这个数组<code>[l, r)</code> 区间的元素重新排序。</p>
<p>TO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>∗</mo><mi>log</mi><mo>⁡</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N*\log M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>是区间距离，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">l, k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>之间的距离。</p>
<p>SO: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>使用<code>priority_queue</code> 模拟小根堆。</p>
</li>
<li>
<p>使用<code>priority_queue</code> 模拟大根堆。</p>
</li>
<li>
<p>用栈+排序。</p>
</li>
</ol>
<h2 id="solution-1">Solution 1</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        std::sort(nums.begin(), nums.end();
        return nums[n-k];
    }
};
</code></pre>
<h2 id="solution-2">Solution 2</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        std::sort(nums.begin(), nums.end(), greater&lt;int&gt;());
        return nums[k-1];
    }
};
</code></pre>
<h2 id="solution-3">Solution 3</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        nth_element(nums.begin(), nums.begin()+k-1, nums.end(), greater&lt;int&gt;());
        return nums[k-1];
    }
};
</code></pre>
<h2 id="solution-4">Solution 4</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater&lt;int&gt;());
        return nums[k - 1];
    }
};
</code></pre>
<h2 id="solution-5">Solution 5</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;
        for (auto num : nums) {
            pq.push(num);
            if (pq.size() &gt; k) {
                pq.pop();
            }
        }
        return pq.top();
    }
};
</code></pre>
<h2 id="solution-6">Solution 6</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int&gt; pq(nums.begin(), nums.end());
        for (int i = 0; i &lt; k-1; i++) {
            pq.pop();
        }
        return pq.top();
    }
};
</code></pre>
<h2 id="solution-7">Solution 7</h2>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        stack&lt;int&gt; st;
        sort(nums.begin(), nums.end(), greater&lt;int&gt;());
        for(int i=0; i&lt;k; i++)
        {
            st.push(nums[i]);
        }
        return st.top();
    }
};
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>参考文章：https://www.cnblogs.com/zwfymqz/p/8503692.html <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 207. Course Schedule]]></title>
        <id>https://tobislee.github.io//post/leetcode-207-course-schedule</id>
        <link href="https://tobislee.github.io//post/leetcode-207-course-schedule">
        </link>
        <updated>2019-12-06T14:27:01.000Z</updated>
        <summary type="html"><![CDATA[<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>
]]></summary>
        <content type="html"><![CDATA[<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>
<!-- more -->
<p><strong>Example 1:</strong></p>
<pre><code>Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.
</code></pre>
<p><strong>Note:</strong></p>
<ol>
<li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs">how a graph is represented</a>.</li>
<li>You may assume that there are no duplicate edges in the input prerequisites.</li>
</ol>
<h2 id="idea">Idea</h2>
<p>其实就是判断图中是否有环，使用拓扑排序，然后将入度为0的结点放入队列中，然后依次出队列，将结点数减一，并将当前结点指向的结点的入度减一，并判断其是否为零，如果为零则加入队列，如果不为零，继续循环。</p>
<h2 id="solution">Solution</h2>
<pre><code class="language-cpp">class Solution {
public:
    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
        // adjacent table;
        vector&lt;vector&lt;int&gt; &gt; adj(numCourses, vector&lt;int&gt;());
        // degree of each node
        vector&lt;int&gt; degree(numCourses, 0);
        for (auto &amp;p : prerequisites) {
            adj[p[1]].push_back(p[0]);
            degree[p[0]]++;
        }
        // to save the elements which are degree = 0;
        queue&lt;int&gt; q;
        for (int i = 0; i &lt; numCourses; i++) if (degree[i] == 0) q.push(i);
        while (!q.empty()) {
            int node = q.front(); q.pop();
            numCourses--;
            for (auto next : adj[node]) {
                if (--degree[next] == 0) q.push(next);
            }
        }
        return numCourses == 0;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>